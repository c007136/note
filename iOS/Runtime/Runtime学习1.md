# Runtime学习1

> 什么是Runtime？

Runtime是一套底层的C语言API，是Objective-C的底层。是Objective-C面向对象和动态机制的基石。

### 静态与动态
对于C语言，采用的是“静态绑定”，函数的调用在编译的时候就会决定运行时调用哪个函数。
对于OC语言，采用的是“动态绑定”，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会确定真正调用的函数是哪个。


## 第一部分：OC元素的认知

Runtime基本构件

1. id和Class
2. IVar
3. SEL
4. IMP
5. Method
6. Cache
7. Category
 


### 类对象（objc_class）
Objective-C中的类是由Class类型来表示的，它实际上是一个objc_class结构体的指针。

```
// Class
struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;

typedef struct objc_class *Class;
```

**从上面的typedef，可以看出Class也是一个对象，称之为类对象**，类对象在编译期用于创建实例对象，是单例。

struct objc_class结构体里保存里类对象，父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存最近使用的方法列表、遵守的协议等。这些变量我们称之为元数据（metadata）。


### 实例（objc_object）

```
struct objc_object {
private:
    isa_t isa;

public:

    // ISA() assumes this is NOT a tagged pointer object
    Class ISA();

    // getIsa() allows this to be a tagged pointer object
    Class getIsa();
    
    ...此处省略其他方法声明

typedef struct objc_object *id;
```


小结：

1. Class是一个指向objc_class结构体的指针
2. id是一个指向objc_object结构体的指针
3. isa是一个指向objc_class结构体的指针
4. id就是我们所说的对象，Class就是我们所说的类


### 元类（metaclass）

定义：the meta-class is the class for a Class object.

简而言之：

* 当你向一个对象发送一条消息的时候，Runtime会在对象的类的方法列表中查找这条消息是否存在。
* 当你向一个类发送一条消息的时候，Runtime会在类的元类的方法列表中查找这条消息是否存在。

![元类关系图](./images/1-1.png)

理解

每个类仅有一个类对象。当发出一个类似[NSObject alloc]的消息时，事实上是把这个消息发给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，也同时是一个根元类（root meta class）的实例。


### IVar
IVar是一种代表类中实例变量的类型

```
struct objc_ivar {
    char * _Nullable ivar_name                               OBJC2_UNAVAILABLE;
    char * _Nullable ivar_type                               OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}                                                            OBJC2_UNAVAILABLE;

typedef struct objc_ivar *Ivar;

struct objc_ivar_list {
    int ivar_count                                           OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;
```


### SEL
A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.

```
typedef struct objc_selector *SEL;
```

简而言之：SEL是一个char *指针。

类的命名规则
* 同一个类，selector不能重复，即函数名不能重复
* 不同的类，selector可以重复


### IMP
A pointer to the function of a method implementation

```
typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); 
```
简而言之：IMP是函数指针


### Method

```
struct objc_method {
    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;
    char * _Nullable method_types                            OBJC2_UNAVAILABLE;
    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;
}

typedef struct objc_method *Method;


struct objc_method_list {
    struct objc_method_list * _Nullable obsolete             OBJC2_UNAVAILABLE;

    int method_count                                         OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;
```

### Cache

```
struct objc_cache {
    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
    unsigned int occupied                                    OBJC2_UNAVAILABLE;
    Method _Nullable buckets[1]                              OBJC2_UNAVAILABLE;
};

typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;
```

为了加速消息派发，系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的。


### Category

```
struct objc_category {
    char * _Nonnull category_name                            OBJC2_UNAVAILABLE;
    char * _Nonnull class_name                               OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable instance_methods     OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable class_methods        OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;

typedef struct objc_category *Category;
```


参考文章：
[浅谈Objective-C中的元类](https://www.jianshu.com/p/79b06fabb459)